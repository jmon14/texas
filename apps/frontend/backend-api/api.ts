/* tslint:disable */
/* eslint-disable */
/**
 * Backend
 * Backend API for Texas Poker Application
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig as RawAxiosRequestConfig,
} from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface ActionDto
 */
export interface ActionDto {
  /**
   * The type of action
   * @type {string}
   * @memberof ActionDto
   */
  type: ActionDtoTypeEnum;
  /**
   * The frequency for this action (0-100)
   * @type {number}
   * @memberof ActionDto
   */
  frequency: number;
  /**
   * Expected value (in big blinds) - Optional, not part of MVP
   * @type {number}
   * @memberof ActionDto
   */
  ev?: number;
  /**
   * Equity vs opponent\'s range (0-100) - Optional, not part of MVP
   * @type {number}
   * @memberof ActionDto
   */
  equity?: number;
}

export const ActionDtoTypeEnum = {
  Fold: 'fold',
  Call: 'call',
  Raise: 'raise',
  Check: 'check',
} as const;

export type ActionDtoTypeEnum = typeof ActionDtoTypeEnum[keyof typeof ActionDtoTypeEnum];

/**
 *
 * @export
 * @interface AttemptFrequencyErrorActionDifferenceDto
 */
export interface AttemptFrequencyErrorActionDifferenceDto {
  /**
   * The action type
   * @type {string}
   * @memberof AttemptFrequencyErrorActionDifferenceDto
   */
  type: AttemptFrequencyErrorActionDifferenceDtoTypeEnum;
  /**
   * User frequency for this action
   * @type {number}
   * @memberof AttemptFrequencyErrorActionDifferenceDto
   */
  userFrequency: number;
  /**
   * GTO frequency for this action
   * @type {number}
   * @memberof AttemptFrequencyErrorActionDifferenceDto
   */
  gtoFrequency: number;
  /**
   * Absolute frequency difference for this action
   * @type {number}
   * @memberof AttemptFrequencyErrorActionDifferenceDto
   */
  difference: number;
}

export const AttemptFrequencyErrorActionDifferenceDtoTypeEnum = {
  Fold: 'fold',
  Call: 'call',
  Raise: 'raise',
  Check: 'check',
} as const;

export type AttemptFrequencyErrorActionDifferenceDtoTypeEnum =
  typeof AttemptFrequencyErrorActionDifferenceDtoTypeEnum[keyof typeof AttemptFrequencyErrorActionDifferenceDtoTypeEnum];

/**
 *
 * @export
 * @interface CompareRangesDto
 */
export interface CompareRangesDto {
  /**
   * The scenario ID to compare against
   * @type {string}
   * @memberof CompareRangesDto
   */
  scenarioId: string;
  /**
   * The user range ID to compare
   * @type {string}
   * @memberof CompareRangesDto
   */
  userRangeId: string;
}
/**
 *
 * @export
 * @interface ComparisonResultDto
 */
export interface ComparisonResultDto {
  /**
   * The attempt ID
   * @type {string}
   * @memberof ComparisonResultDto
   */
  attemptId: string;
  /**
   * The attempt number for this user/scenario
   * @type {number}
   * @memberof ComparisonResultDto
   */
  attemptNumber: number;
  /**
   * Accuracy score (0-100)
   * @type {number}
   * @memberof ComparisonResultDto
   */
  accuracyScore: number;
  /**
   * Hands that match GTO within frequency threshold
   * @type {Array<CorrectHandDto>}
   * @memberof ComparisonResultDto
   */
  correct: Array<CorrectHandDto>;
  /**
   * Hands in GTO range but not in user range
   * @type {Array<MissingHandDto>}
   * @memberof ComparisonResultDto
   */
  missing: Array<MissingHandDto>;
  /**
   * Hands in user range but not in GTO range
   * @type {Array<ExtraHandDto>}
   * @memberof ComparisonResultDto
   */
  extra: Array<ExtraHandDto>;
  /**
   * Hands with frequency differences exceeding threshold (per-action breakdown)
   * @type {Array<FrequencyErrorHandDto>}
   * @memberof ComparisonResultDto
   */
  frequencyError: Array<FrequencyErrorHandDto>;
  /**
   * Overall feedback summary
   * @type {string}
   * @memberof ComparisonResultDto
   */
  overallFeedback: string;
}
/**
 *
 * @export
 * @interface CorrectHandDto
 */
export interface CorrectHandDto {
  /**
   * The hand label
   * @type {string}
   * @memberof CorrectHandDto
   */
  hand: string;
  /**
   * User actions for this hand
   * @type {Array<ActionDto>}
   * @memberof CorrectHandDto
   */
  userAction: Array<ActionDto>;
  /**
   * GTO actions for this hand
   * @type {Array<ActionDto>}
   * @memberof CorrectHandDto
   */
  gtoAction: Array<ActionDto>;
}
/**
 *
 * @export
 * @interface CreateRangeDto
 */
export interface CreateRangeDto {
  /**
   * The name of the range
   * @type {string}
   * @memberof CreateRangeDto
   */
  name: string;
  /**
   * Array of hand ranges
   * @type {Array<HandRangeDto>}
   * @memberof CreateRangeDto
   */
  handsRange: Array<HandRangeDto>;
  /**
   * The user ID who owns this range
   * @type {string}
   * @memberof CreateRangeDto
   */
  userId: string;
}
/**
 *
 * @export
 * @interface CreateScenarioDto
 */
export interface CreateScenarioDto {
  /**
   * The name of the scenario
   * @type {string}
   * @memberof CreateScenarioDto
   */
  name: string;
  /**
   * Detailed description of the scenario
   * @type {string}
   * @memberof CreateScenarioDto
   */
  description: string;
  /**
   * The street where this decision occurs
   * @type {string}
   * @memberof CreateScenarioDto
   */
  street: CreateScenarioDtoStreetEnum;
  /**
   * The game type
   * @type {string}
   * @memberof CreateScenarioDto
   */
  gameType: CreateScenarioDtoGameTypeEnum;
  /**
   * Hero position
   * @type {string}
   * @memberof CreateScenarioDto
   */
  position: CreateScenarioDtoPositionEnum;
  /**
   * Villain position
   * @type {string}
   * @memberof CreateScenarioDto
   */
  vsPosition: CreateScenarioDtoVsPositionEnum;
  /**
   * The scenario action type (what decision is being made)
   * @type {string}
   * @memberof CreateScenarioDto
   */
  actionType: CreateScenarioDtoActionTypeEnum;
  /**
   * Effective stack depth in big blinds
   * @type {number}
   * @memberof CreateScenarioDto
   */
  effectiveStack: number;
  /**
   * Bet size in big blinds
   * @type {number}
   * @memberof CreateScenarioDto
   */
  betSize: number;
  /**
   * Previous actions in the hand
   * @type {Array<PreviousActionDto>}
   * @memberof CreateScenarioDto
   */
  previousActions?: Array<PreviousActionDto>;
  /**
   * Board cards in format \"As Kh 7d\" (3 cards for flop, 4 for turn, 5 for river). Required for post-flop scenarios.
   * @type {string}
   * @memberof CreateScenarioDto
   */
  boardCards?: string;
  /**
   * Board texture description. Required for post-flop scenarios.
   * @type {string}
   * @memberof CreateScenarioDto
   */
  boardTexture?: CreateScenarioDtoBoardTextureEnum;
  /**
   * Difficulty level
   * @type {string}
   * @memberof CreateScenarioDto
   */
  difficulty: CreateScenarioDtoDifficultyEnum;
  /**
   * Category of the scenario
   * @type {string}
   * @memberof CreateScenarioDto
   */
  category: CreateScenarioDtoCategoryEnum;
  /**
   * Tags for filtering and organization
   * @type {Array<string>}
   * @memberof CreateScenarioDto
   */
  tags: Array<string>;
}

export const CreateScenarioDtoStreetEnum = {
  Preflop: 'preflop',
  Flop: 'flop',
  Turn: 'turn',
  River: 'river',
} as const;

export type CreateScenarioDtoStreetEnum =
  typeof CreateScenarioDtoStreetEnum[keyof typeof CreateScenarioDtoStreetEnum];
export const CreateScenarioDtoGameTypeEnum = {
  Cash: 'cash',
  Tournament: 'tournament',
} as const;

export type CreateScenarioDtoGameTypeEnum =
  typeof CreateScenarioDtoGameTypeEnum[keyof typeof CreateScenarioDtoGameTypeEnum];
export const CreateScenarioDtoPositionEnum = {
  Utg: 'UTG',
  Mp: 'MP',
  Co: 'CO',
  Btn: 'BTN',
  Sb: 'SB',
  Bb: 'BB',
} as const;

export type CreateScenarioDtoPositionEnum =
  typeof CreateScenarioDtoPositionEnum[keyof typeof CreateScenarioDtoPositionEnum];
export const CreateScenarioDtoVsPositionEnum = {
  Utg: 'UTG',
  Mp: 'MP',
  Co: 'CO',
  Btn: 'BTN',
  Sb: 'SB',
  Bb: 'BB',
} as const;

export type CreateScenarioDtoVsPositionEnum =
  typeof CreateScenarioDtoVsPositionEnum[keyof typeof CreateScenarioDtoVsPositionEnum];
export const CreateScenarioDtoActionTypeEnum = {
  Cbet: 'cbet',
  VsCbetCall: 'vs_cbet_call',
  VsCbetRaise: 'vs_cbet_raise',
  Open: 'open',
  VsOpenCall: 'vs_open_call',
  VsOpen3bet: 'vs_open_3bet',
  Vs3bet: 'vs_3bet',
  Vs4bet: 'vs_4bet',
} as const;

export type CreateScenarioDtoActionTypeEnum =
  typeof CreateScenarioDtoActionTypeEnum[keyof typeof CreateScenarioDtoActionTypeEnum];
export const CreateScenarioDtoBoardTextureEnum = {
  Dry: 'dry',
  Wet: 'wet',
  Paired: 'paired',
  Monotone: 'monotone',
  Rainbow: 'rainbow',
  High: 'high',
  Low: 'low',
} as const;

export type CreateScenarioDtoBoardTextureEnum =
  typeof CreateScenarioDtoBoardTextureEnum[keyof typeof CreateScenarioDtoBoardTextureEnum];
export const CreateScenarioDtoDifficultyEnum = {
  Beginner: 'beginner',
  Intermediate: 'intermediate',
  Advanced: 'advanced',
} as const;

export type CreateScenarioDtoDifficultyEnum =
  typeof CreateScenarioDtoDifficultyEnum[keyof typeof CreateScenarioDtoDifficultyEnum];
export const CreateScenarioDtoCategoryEnum = {
  OpeningRanges: 'Opening Ranges',
  _3Betting: '3-Betting',
  DefendingBb: 'Defending BB',
  CallingRanges: 'Calling Ranges',
} as const;

export type CreateScenarioDtoCategoryEnum =
  typeof CreateScenarioDtoCategoryEnum[keyof typeof CreateScenarioDtoCategoryEnum];

/**
 *
 * @export
 * @interface ExtraHandDto
 */
export interface ExtraHandDto {
  /**
   * The hand label
   * @type {string}
   * @memberof ExtraHandDto
   */
  hand: string;
  /**
   * User actions for this hand
   * @type {Array<ActionDto>}
   * @memberof ExtraHandDto
   */
  userAction: Array<ActionDto>;
  /**
   * Reason why this hand is extra
   * @type {string}
   * @memberof ExtraHandDto
   */
  reason: string;
}
/**
 *
 * @export
 * @interface FileEntity
 */
export interface FileEntity {
  /**
   *
   * @type {string}
   * @memberof FileEntity
   */
  url: string;
  /**
   *
   * @type {number}
   * @memberof FileEntity
   */
  size: number;
  /**
   *
   * @type {string}
   * @memberof FileEntity
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof FileEntity
   */
  user: string;
}
/**
 *
 * @export
 * @interface FrequencyErrorActionDifferenceDto
 */
export interface FrequencyErrorActionDifferenceDto {
  /**
   * The action type
   * @type {string}
   * @memberof FrequencyErrorActionDifferenceDto
   */
  type: FrequencyErrorActionDifferenceDtoTypeEnum;
  /**
   * User frequency for this action type
   * @type {number}
   * @memberof FrequencyErrorActionDifferenceDto
   */
  userFrequency: number;
  /**
   * GTO frequency for this action type
   * @type {number}
   * @memberof FrequencyErrorActionDifferenceDto
   */
  gtoFrequency: number;
  /**
   * Absolute frequency difference for this action type
   * @type {number}
   * @memberof FrequencyErrorActionDifferenceDto
   */
  difference: number;
}

export const FrequencyErrorActionDifferenceDtoTypeEnum = {
  Fold: 'fold',
  Call: 'call',
  Raise: 'raise',
  Check: 'check',
} as const;

export type FrequencyErrorActionDifferenceDtoTypeEnum =
  typeof FrequencyErrorActionDifferenceDtoTypeEnum[keyof typeof FrequencyErrorActionDifferenceDtoTypeEnum];

/**
 *
 * @export
 * @interface FrequencyErrorDto
 */
export interface FrequencyErrorDto {
  /**
   * The hand label
   * @type {string}
   * @memberof FrequencyErrorDto
   */
  hand: string;
  /**
   * Maximum absolute frequency difference across actions
   * @type {number}
   * @memberof FrequencyErrorDto
   */
  maxDifference: number;
  /**
   * Per-action differences
   * @type {Array<AttemptFrequencyErrorActionDifferenceDto>}
   * @memberof FrequencyErrorDto
   */
  actions: Array<AttemptFrequencyErrorActionDifferenceDto>;
}
/**
 *
 * @export
 * @interface FrequencyErrorHandDto
 */
export interface FrequencyErrorHandDto {
  /**
   * The hand label
   * @type {string}
   * @memberof FrequencyErrorHandDto
   */
  hand: string;
  /**
   * User actions for this hand
   * @type {Array<ActionDto>}
   * @memberof FrequencyErrorHandDto
   */
  userAction: Array<ActionDto>;
  /**
   * GTO actions for this hand
   * @type {Array<ActionDto>}
   * @memberof FrequencyErrorHandDto
   */
  gtoAction: Array<ActionDto>;
  /**
   * Maximum absolute frequency difference across actions
   * @type {number}
   * @memberof FrequencyErrorHandDto
   */
  maxDifference: number;
  /**
   * Per-action frequency differences
   * @type {Array<FrequencyErrorActionDifferenceDto>}
   * @memberof FrequencyErrorHandDto
   */
  actions: Array<FrequencyErrorActionDifferenceDto>;
}
/**
 *
 * @export
 * @interface HandRangeDto
 */
export interface HandRangeDto {
  /**
   * The carryover frequency from previous street (0-100)
   * @type {number}
   * @memberof HandRangeDto
   */
  carryoverFrequency: number;
  /**
   * The label for this hand range
   * @type {string}
   * @memberof HandRangeDto
   */
  label: string;
  /**
   * Array of actions for this hand range
   * @type {Array<ActionDto>}
   * @memberof HandRangeDto
   */
  actions: Array<ActionDto>;
}
/**
 *
 * @export
 * @interface MissingHandDto
 */
export interface MissingHandDto {
  /**
   * The hand label
   * @type {string}
   * @memberof MissingHandDto
   */
  hand: string;
  /**
   * GTO actions for this hand
   * @type {Array<ActionDto>}
   * @memberof MissingHandDto
   */
  gtoAction: Array<ActionDto>;
  /**
   * Reason why this hand is missing
   * @type {string}
   * @memberof MissingHandDto
   */
  reason: string;
}
/**
 *
 * @export
 * @interface PreviousActionDto
 */
export interface PreviousActionDto {
  /**
   * Position that took this action
   * @type {string}
   * @memberof PreviousActionDto
   */
  position: PreviousActionDtoPositionEnum;
  /**
   * Type of action taken
   * @type {string}
   * @memberof PreviousActionDto
   */
  actionType: PreviousActionDtoActionTypeEnum;
  /**
   * Bet/raise size in big blinds (required for raises)
   * @type {number}
   * @memberof PreviousActionDto
   */
  sizing?: number;
}

export const PreviousActionDtoPositionEnum = {
  Utg: 'UTG',
  Mp: 'MP',
  Co: 'CO',
  Btn: 'BTN',
  Sb: 'SB',
  Bb: 'BB',
} as const;

export type PreviousActionDtoPositionEnum =
  typeof PreviousActionDtoPositionEnum[keyof typeof PreviousActionDtoPositionEnum];
export const PreviousActionDtoActionTypeEnum = {
  Fold: 'fold',
  Call: 'call',
  Raise: 'raise',
  Check: 'check',
} as const;

export type PreviousActionDtoActionTypeEnum =
  typeof PreviousActionDtoActionTypeEnum[keyof typeof PreviousActionDtoActionTypeEnum];

/**
 *
 * @export
 * @interface RangeResponseDto
 */
export interface RangeResponseDto {
  /**
   * The unique MongoDB identifier of the range
   * @type {string}
   * @memberof RangeResponseDto
   */
  _id: string;
  /**
   * The name of the range
   * @type {string}
   * @memberof RangeResponseDto
   */
  name: string;
  /**
   * Array of hand ranges with actions
   * @type {Array<HandRangeDto>}
   * @memberof RangeResponseDto
   */
  handsRange: Array<HandRangeDto>;
  /**
   * The user ID who owns this range
   * @type {string}
   * @memberof RangeResponseDto
   */
  userId: string;
}
/**
 *
 * @export
 * @interface ReferenceRangeResponseDto
 */
export interface ReferenceRangeResponseDto {
  /**
   * The unique MongoDB identifier of the reference range
   * @type {string}
   * @memberof ReferenceRangeResponseDto
   */
  _id: string;
  /**
   * The scenario ID this reference range belongs to
   * @type {string}
   * @memberof ReferenceRangeResponseDto
   */
  scenarioId: string;
  /**
   * The GTO solution range data
   * @type {RangeResponseDto}
   * @memberof ReferenceRangeResponseDto
   */
  rangeData: RangeResponseDto;
  /**
   * The solver used to generate this range
   * @type {string}
   * @memberof ReferenceRangeResponseDto
   */
  solver: string;
  /**
   * The version of the solver
   * @type {string}
   * @memberof ReferenceRangeResponseDto
   */
  solverVersion: string;
  /**
   * When this range was solved
   * @type {string}
   * @memberof ReferenceRangeResponseDto
   */
  solveDate: string;
  /**
   * Solver parameters used
   * @type {SolveParametersDto}
   * @memberof ReferenceRangeResponseDto
   */
  solveParameters?: SolveParametersDto;
  /**
   * Exploitability score (Nash distance)
   * @type {number}
   * @memberof ReferenceRangeResponseDto
   */
  exploitability?: number;
  /**
   * Whether this range has been manually verified
   * @type {boolean}
   * @memberof ReferenceRangeResponseDto
   */
  verified: boolean;
  /**
   * When this reference range was created
   * @type {string}
   * @memberof ReferenceRangeResponseDto
   */
  createdAt: string;
  /**
   * When this reference range was last updated
   * @type {string}
   * @memberof ReferenceRangeResponseDto
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface ResetPwdDto
 */
export interface ResetPwdDto {
  /**
   *
   * @type {string}
   * @memberof ResetPwdDto
   */
  password: string;
}
/**
 *
 * @export
 * @interface ScenarioResponseDto
 */
export interface ScenarioResponseDto {
  /**
   * The unique MongoDB identifier of the scenario
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  _id: string;
  /**
   * The name of the scenario
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  name: string;
  /**
   * Detailed description of the scenario
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  description: string;
  /**
   * The street where this decision occurs
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  street: ScenarioResponseDtoStreetEnum;
  /**
   * The game type
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  gameType: ScenarioResponseDtoGameTypeEnum;
  /**
   * Hero position
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  position: ScenarioResponseDtoPositionEnum;
  /**
   * Villain position
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  vsPosition: ScenarioResponseDtoVsPositionEnum;
  /**
   * The scenario action type (what decision is being made)
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  actionType: ScenarioResponseDtoActionTypeEnum;
  /**
   * Effective stack depth in big blinds
   * @type {number}
   * @memberof ScenarioResponseDto
   */
  effectiveStack: number;
  /**
   * Bet size in big blinds
   * @type {number}
   * @memberof ScenarioResponseDto
   */
  betSize: number;
  /**
   * Previous actions in the hand
   * @type {Array<PreviousActionDto>}
   * @memberof ScenarioResponseDto
   */
  previousActions?: Array<PreviousActionDto>;
  /**
   * Board cards in format \"As Kh 7d\" (3 cards for flop, 4 for turn, 5 for river). Present for post-flop scenarios.
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  boardCards?: string;
  /**
   * Board texture description. Required for post-flop scenarios.
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  boardTexture?: ScenarioResponseDtoBoardTextureEnum;
  /**
   * Difficulty level
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  difficulty: ScenarioResponseDtoDifficultyEnum;
  /**
   * Category of the scenario
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  category: ScenarioResponseDtoCategoryEnum;
  /**
   * Tags for filtering and organization
   * @type {Array<string>}
   * @memberof ScenarioResponseDto
   */
  tags: Array<string>;
  /**
   * Creation timestamp
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  createdAt: string;
  /**
   * Last update timestamp
   * @type {string}
   * @memberof ScenarioResponseDto
   */
  updatedAt: string;
}

export const ScenarioResponseDtoStreetEnum = {
  Preflop: 'preflop',
  Flop: 'flop',
  Turn: 'turn',
  River: 'river',
} as const;

export type ScenarioResponseDtoStreetEnum =
  typeof ScenarioResponseDtoStreetEnum[keyof typeof ScenarioResponseDtoStreetEnum];
export const ScenarioResponseDtoGameTypeEnum = {
  Cash: 'cash',
  Tournament: 'tournament',
} as const;

export type ScenarioResponseDtoGameTypeEnum =
  typeof ScenarioResponseDtoGameTypeEnum[keyof typeof ScenarioResponseDtoGameTypeEnum];
export const ScenarioResponseDtoPositionEnum = {
  Utg: 'UTG',
  Mp: 'MP',
  Co: 'CO',
  Btn: 'BTN',
  Sb: 'SB',
  Bb: 'BB',
} as const;

export type ScenarioResponseDtoPositionEnum =
  typeof ScenarioResponseDtoPositionEnum[keyof typeof ScenarioResponseDtoPositionEnum];
export const ScenarioResponseDtoVsPositionEnum = {
  Utg: 'UTG',
  Mp: 'MP',
  Co: 'CO',
  Btn: 'BTN',
  Sb: 'SB',
  Bb: 'BB',
} as const;

export type ScenarioResponseDtoVsPositionEnum =
  typeof ScenarioResponseDtoVsPositionEnum[keyof typeof ScenarioResponseDtoVsPositionEnum];
export const ScenarioResponseDtoActionTypeEnum = {
  Cbet: 'cbet',
  VsCbetCall: 'vs_cbet_call',
  VsCbetRaise: 'vs_cbet_raise',
  Open: 'open',
  VsOpenCall: 'vs_open_call',
  VsOpen3bet: 'vs_open_3bet',
  Vs3bet: 'vs_3bet',
  Vs4bet: 'vs_4bet',
} as const;

export type ScenarioResponseDtoActionTypeEnum =
  typeof ScenarioResponseDtoActionTypeEnum[keyof typeof ScenarioResponseDtoActionTypeEnum];
export const ScenarioResponseDtoBoardTextureEnum = {
  Dry: 'dry',
  Wet: 'wet',
  Paired: 'paired',
  Monotone: 'monotone',
  Rainbow: 'rainbow',
  High: 'high',
  Low: 'low',
} as const;

export type ScenarioResponseDtoBoardTextureEnum =
  typeof ScenarioResponseDtoBoardTextureEnum[keyof typeof ScenarioResponseDtoBoardTextureEnum];
export const ScenarioResponseDtoDifficultyEnum = {
  Beginner: 'beginner',
  Intermediate: 'intermediate',
  Advanced: 'advanced',
} as const;

export type ScenarioResponseDtoDifficultyEnum =
  typeof ScenarioResponseDtoDifficultyEnum[keyof typeof ScenarioResponseDtoDifficultyEnum];
export const ScenarioResponseDtoCategoryEnum = {
  OpeningRanges: 'Opening Ranges',
  _3Betting: '3-Betting',
  DefendingBb: 'Defending BB',
  CallingRanges: 'Calling Ranges',
} as const;

export type ScenarioResponseDtoCategoryEnum =
  typeof ScenarioResponseDtoCategoryEnum[keyof typeof ScenarioResponseDtoCategoryEnum];

/**
 *
 * @export
 * @interface SolveParametersDto
 */
export interface SolveParametersDto {
  /**
   * Number of solver iterations
   * @type {number}
   * @memberof SolveParametersDto
   */
  iterations: number;
  /**
   * Solver accuracy threshold
   * @type {string}
   * @memberof SolveParametersDto
   */
  accuracy: string;
  /**
   * Rake structure (optional)
   * @type {string}
   * @memberof SolveParametersDto
   */
  rakeStructure?: string;
}
/**
 *
 * @export
 * @interface UpdateRangeDto
 */
export interface UpdateRangeDto {
  /**
   * The name of the range
   * @type {string}
   * @memberof UpdateRangeDto
   */
  name?: string;
  /**
   * Array of hand ranges
   * @type {Array<HandRangeDto>}
   * @memberof UpdateRangeDto
   */
  handsRange?: Array<HandRangeDto>;
  /**
   * The user ID who owns this range
   * @type {string}
   * @memberof UpdateRangeDto
   */
  userId?: string;
}
/**
 *
 * @export
 * @interface UserEntity
 */
export interface UserEntity {
  /**
   *
   * @type {string}
   * @memberof UserEntity
   */
  username: string;
  /**
   *
   * @type {boolean}
   * @memberof UserEntity
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof UserEntity
   */
  email: string;
  /**
   *
   * @type {Array<FileEntity>}
   * @memberof UserEntity
   */
  files: Array<FileEntity>;
}
/**
 *
 * @export
 * @interface UserRangeAttemptComparisonResultDto
 */
export interface UserRangeAttemptComparisonResultDto {
  /**
   * Accuracy score (0-100)
   * @type {number}
   * @memberof UserRangeAttemptComparisonResultDto
   */
  accuracyScore: number;
  /**
   * Hands missing from user range
   * @type {Array<string>}
   * @memberof UserRangeAttemptComparisonResultDto
   */
  missingHands: Array<string>;
  /**
   * Hands extra in user range
   * @type {Array<string>}
   * @memberof UserRangeAttemptComparisonResultDto
   */
  extraHands: Array<string>;
  /**
   * Frequency errors with per-action differences
   * @type {Array<FrequencyErrorDto>}
   * @memberof UserRangeAttemptComparisonResultDto
   */
  frequencyErrors: Array<FrequencyErrorDto>;
}
/**
 *
 * @export
 * @interface UserRangeAttemptResponseDto
 */
export interface UserRangeAttemptResponseDto {
  /**
   * The unique MongoDB identifier
   * @type {string}
   * @memberof UserRangeAttemptResponseDto
   */
  _id: string;
  /**
   * The user ID
   * @type {string}
   * @memberof UserRangeAttemptResponseDto
   */
  userId: string;
  /**
   * The scenario ID
   * @type {string}
   * @memberof UserRangeAttemptResponseDto
   */
  scenarioId: string;
  /**
   * The range ID
   * @type {string}
   * @memberof UserRangeAttemptResponseDto
   */
  rangeId: string;
  /**
   * Comparison results
   * @type {UserRangeAttemptComparisonResultDto}
   * @memberof UserRangeAttemptResponseDto
   */
  comparisonResult: UserRangeAttemptComparisonResultDto;
  /**
   * The attempt number
   * @type {number}
   * @memberof UserRangeAttemptResponseDto
   */
  attemptNumber: number;
  /**
   * Creation timestamp
   * @type {string}
   * @memberof UserRangeAttemptResponseDto
   */
  createdAt: string;
  /**
   * Last update timestamp
   * @type {string}
   * @memberof UserRangeAttemptResponseDto
   */
  updatedAt: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {object} body Use username and password for authentication and return user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('login', 'body', body);
      const localVarPath = `/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {object} body Resend email verification link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendVerificationEmail: async (
      body: object,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('resendVerificationEmail', 'body', body);
      const localVarPath = `/auth/resend-verification`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {object} body Send email with reset password link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendResetEmail: async (
      body: object,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('sendResetEmail', 'body', body);
      const localVarPath = `/auth/reset`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {object} body Use username and password for authentication and return user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      body: object,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEntity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refresh(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEntity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.refresh']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {object} body Resend email verification link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resendVerificationEmail(
      body: object,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resendVerificationEmail(
        body,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.resendVerificationEmail']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {object} body Send email with reset password link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendResetEmail(
      body: object,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendResetEmail(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.sendResetEmail']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     *
     * @param {object} body Use username and password for authentication and return user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(body: object, options?: RawAxiosRequestConfig): AxiosPromise<UserEntity> {
      return localVarFp.login(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.logout(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh(options?: RawAxiosRequestConfig): AxiosPromise<UserEntity> {
      return localVarFp.refresh(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {object} body Resend email verification link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendVerificationEmail(body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .resendVerificationEmail(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {object} body Send email with reset password link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendResetEmail(body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.sendResetEmail(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @param {object} body Use username and password for authentication and return user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public login(body: object, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .login(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public logout(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public refresh(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .refresh(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body Resend email verification link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public resendVerificationEmail(body: object, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .resendVerificationEmail(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body Send email with reset password link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public sendResetEmail(body: object, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .sendResetEmail(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFilesById: async (id: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFilesById', 'id', id);
      const localVarPath = `/files/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesById: async (id: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFilesById', 'id', id);
      const localVarPath = `/files/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/files/upload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFiles(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFiles(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.deleteFiles']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {any} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFilesById(
      id: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFilesById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.deleteFilesById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFiles(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileEntity>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.getFiles']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {any} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilesById(
      id: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.getFilesById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileEntity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.uploadFile']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FilesApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFiles(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.deleteFiles(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {any} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFilesById(id: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.deleteFilesById(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles(options?: RawAxiosRequestConfig): AxiosPromise<Array<FileEntity>> {
      return localVarFp.getFiles(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {any} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesById(id: any, options?: RawAxiosRequestConfig): AxiosPromise<FileEntity> {
      return localVarFp.getFilesById(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(options?: RawAxiosRequestConfig): AxiosPromise<FileEntity> {
      return localVarFp.uploadFile(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public deleteFiles(options?: RawAxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .deleteFiles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} id File ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public deleteFilesById(id: any, options?: RawAxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .deleteFilesById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFiles(options?: RawAxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .getFiles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} id File ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFilesById(id: any, options?: RawAxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .getFilesById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public uploadFile(options?: RawAxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .uploadFile(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHealth(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['HealthApi.getHealth']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.getHealth(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getHealth(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .getHealth(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RangesApi - axios parameter creator
 * @export
 */
export const RangesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a new range
     * @param {CreateRangeDto} createRangeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRange: async (
      createRangeDto: CreateRangeDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createRangeDto' is not null or undefined
      assertParamExists('createRange', 'createRangeDto', createRangeDto);
      const localVarPath = `/ranges`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createRangeDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a range
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRange: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteRange', 'id', id);
      const localVarPath = `/ranges/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a range by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRangeById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getRangeById', 'id', id);
      const localVarPath = `/ranges/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all ranges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRanges: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ranges`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get ranges by user ID
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRangesByUserId: async (
      userId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getRangesByUserId', 'userId', userId);
      const localVarPath = `/ranges/user/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a range
     * @param {string} id
     * @param {UpdateRangeDto} updateRangeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRange: async (
      id: string,
      updateRangeDto: UpdateRangeDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateRange', 'id', id);
      // verify required parameter 'updateRangeDto' is not null or undefined
      assertParamExists('updateRange', 'updateRangeDto', updateRangeDto);
      const localVarPath = `/ranges/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateRangeDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RangesApi - functional programming interface
 * @export
 */
export const RangesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RangesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a new range
     * @param {CreateRangeDto} createRangeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRange(
      createRangeDto: CreateRangeDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRange(
        createRangeDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RangesApi.createRange']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a range
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRange(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRange(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RangesApi.deleteRange']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a range by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRangeById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRangeById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RangesApi.getRangeById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all ranges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRanges(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RangeResponseDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRanges(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RangesApi.getRanges']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get ranges by user ID
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRangesByUserId(
      userId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RangeResponseDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRangesByUserId(userId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RangesApi.getRangesByUserId']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update a range
     * @param {string} id
     * @param {UpdateRangeDto} updateRangeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRange(
      id: string,
      updateRangeDto: UpdateRangeDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRange(
        id,
        updateRangeDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RangesApi.updateRange']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RangesApi - factory interface
 * @export
 */
export const RangesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RangesApiFp(configuration);
  return {
    /**
     *
     * @summary Create a new range
     * @param {CreateRangeDto} createRangeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRange(
      createRangeDto: CreateRangeDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<RangeResponseDto> {
      return localVarFp
        .createRange(createRangeDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a range
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRange(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.deleteRange(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a range by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRangeById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeResponseDto> {
      return localVarFp.getRangeById(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all ranges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRanges(options?: RawAxiosRequestConfig): AxiosPromise<Array<RangeResponseDto>> {
      return localVarFp.getRanges(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get ranges by user ID
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRangesByUserId(
      userId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<RangeResponseDto>> {
      return localVarFp
        .getRangesByUserId(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a range
     * @param {string} id
     * @param {UpdateRangeDto} updateRangeDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRange(
      id: string,
      updateRangeDto: UpdateRangeDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<RangeResponseDto> {
      return localVarFp
        .updateRange(id, updateRangeDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RangesApi - object-oriented interface
 * @export
 * @class RangesApi
 * @extends {BaseAPI}
 */
export class RangesApi extends BaseAPI {
  /**
   *
   * @summary Create a new range
   * @param {CreateRangeDto} createRangeDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RangesApi
   */
  public createRange(createRangeDto: CreateRangeDto, options?: RawAxiosRequestConfig) {
    return RangesApiFp(this.configuration)
      .createRange(createRangeDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a range
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RangesApi
   */
  public deleteRange(id: string, options?: RawAxiosRequestConfig) {
    return RangesApiFp(this.configuration)
      .deleteRange(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a range by ID
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RangesApi
   */
  public getRangeById(id: string, options?: RawAxiosRequestConfig) {
    return RangesApiFp(this.configuration)
      .getRangeById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all ranges
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RangesApi
   */
  public getRanges(options?: RawAxiosRequestConfig) {
    return RangesApiFp(this.configuration)
      .getRanges(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get ranges by user ID
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RangesApi
   */
  public getRangesByUserId(userId: string, options?: RawAxiosRequestConfig) {
    return RangesApiFp(this.configuration)
      .getRangesByUserId(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a range
   * @param {string} id
   * @param {UpdateRangeDto} updateRangeDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RangesApi
   */
  public updateRange(id: string, updateRangeDto: UpdateRangeDto, options?: RawAxiosRequestConfig) {
    return RangesApiFp(this.configuration)
      .updateRange(id, updateRangeDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ReferenceRangesApi - axios parameter creator
 * @export
 */
export const ReferenceRangesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns the GTO-solved reference range for a specific scenario. This is a public endpoint (no authentication required) as reference ranges are read-only GTO solutions. Supports both preflop and post-flop scenarios.
     * @summary Get reference range for a scenario
     * @param {string} scenarioId The ID of the scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByScenarioId: async (
      scenarioId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'scenarioId' is not null or undefined
      assertParamExists('getByScenarioId', 'scenarioId', scenarioId);
      const localVarPath = `/reference-ranges/scenario/{scenarioId}`.replace(
        `{${'scenarioId'}}`,
        encodeURIComponent(String(scenarioId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Batch import: solves and imports reference ranges for all scenarios in the database. Uses TexasSolver to compute GTO solutions. Supports both preflop and post-flop scenarios. Requires authentication.
     * @summary Import reference ranges for all scenarios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importAllScenarios: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/reference-ranges/import-all`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Solves and imports a reference range for a specific scenario. Uses TexasSolver to compute GTO solution. Supports both preflop and post-flop scenarios. Requires authentication.
     * @summary Import reference range for a scenario
     * @param {string} scenarioId The ID of the scenario to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importForScenario: async (
      scenarioId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'scenarioId' is not null or undefined
      assertParamExists('importForScenario', 'scenarioId', scenarioId);
      const localVarPath = `/reference-ranges/scenario/{scenarioId}/import`.replace(
        `{${'scenarioId'}}`,
        encodeURIComponent(String(scenarioId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ReferenceRangesApi - functional programming interface
 * @export
 */
export const ReferenceRangesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ReferenceRangesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the GTO-solved reference range for a specific scenario. This is a public endpoint (no authentication required) as reference ranges are read-only GTO solutions. Supports both preflop and post-flop scenarios.
     * @summary Get reference range for a scenario
     * @param {string} scenarioId The ID of the scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getByScenarioId(
      scenarioId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceRangeResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getByScenarioId(
        scenarioId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReferenceRangesApi.getByScenarioId']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Batch import: solves and imports reference ranges for all scenarios in the database. Uses TexasSolver to compute GTO solutions. Supports both preflop and post-flop scenarios. Requires authentication.
     * @summary Import reference ranges for all scenarios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async importAllScenarios(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReferenceRangeResponseDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.importAllScenarios(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReferenceRangesApi.importAllScenarios']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Solves and imports a reference range for a specific scenario. Uses TexasSolver to compute GTO solution. Supports both preflop and post-flop scenarios. Requires authentication.
     * @summary Import reference range for a scenario
     * @param {string} scenarioId The ID of the scenario to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async importForScenario(
      scenarioId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceRangeResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.importForScenario(
        scenarioId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReferenceRangesApi.importForScenario']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ReferenceRangesApi - factory interface
 * @export
 */
export const ReferenceRangesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ReferenceRangesApiFp(configuration);
  return {
    /**
     * Returns the GTO-solved reference range for a specific scenario. This is a public endpoint (no authentication required) as reference ranges are read-only GTO solutions. Supports both preflop and post-flop scenarios.
     * @summary Get reference range for a scenario
     * @param {string} scenarioId The ID of the scenario
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getByScenarioId(
      scenarioId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ReferenceRangeResponseDto> {
      return localVarFp
        .getByScenarioId(scenarioId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Batch import: solves and imports reference ranges for all scenarios in the database. Uses TexasSolver to compute GTO solutions. Supports both preflop and post-flop scenarios. Requires authentication.
     * @summary Import reference ranges for all scenarios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importAllScenarios(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ReferenceRangeResponseDto>> {
      return localVarFp.importAllScenarios(options).then((request) => request(axios, basePath));
    },
    /**
     * Solves and imports a reference range for a specific scenario. Uses TexasSolver to compute GTO solution. Supports both preflop and post-flop scenarios. Requires authentication.
     * @summary Import reference range for a scenario
     * @param {string} scenarioId The ID of the scenario to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importForScenario(
      scenarioId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ReferenceRangeResponseDto> {
      return localVarFp
        .importForScenario(scenarioId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ReferenceRangesApi - object-oriented interface
 * @export
 * @class ReferenceRangesApi
 * @extends {BaseAPI}
 */
export class ReferenceRangesApi extends BaseAPI {
  /**
   * Returns the GTO-solved reference range for a specific scenario. This is a public endpoint (no authentication required) as reference ranges are read-only GTO solutions. Supports both preflop and post-flop scenarios.
   * @summary Get reference range for a scenario
   * @param {string} scenarioId The ID of the scenario
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceRangesApi
   */
  public getByScenarioId(scenarioId: string, options?: RawAxiosRequestConfig) {
    return ReferenceRangesApiFp(this.configuration)
      .getByScenarioId(scenarioId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Batch import: solves and imports reference ranges for all scenarios in the database. Uses TexasSolver to compute GTO solutions. Supports both preflop and post-flop scenarios. Requires authentication.
   * @summary Import reference ranges for all scenarios
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceRangesApi
   */
  public importAllScenarios(options?: RawAxiosRequestConfig) {
    return ReferenceRangesApiFp(this.configuration)
      .importAllScenarios(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Solves and imports a reference range for a specific scenario. Uses TexasSolver to compute GTO solution. Supports both preflop and post-flop scenarios. Requires authentication.
   * @summary Import reference range for a scenario
   * @param {string} scenarioId The ID of the scenario to import
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceRangesApi
   */
  public importForScenario(scenarioId: string, options?: RawAxiosRequestConfig) {
    return ReferenceRangesApiFp(this.configuration)
      .importForScenario(scenarioId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ScenariosApi - axios parameter creator
 * @export
 */
export const ScenariosApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a new scenario
     * @param {CreateScenarioDto} createScenarioDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScenario: async (
      createScenarioDto: CreateScenarioDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createScenarioDto' is not null or undefined
      assertParamExists('createScenario', 'createScenarioDto', createScenarioDto);
      const localVarPath = `/scenarios`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createScenarioDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a scenario by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenarioById: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getScenarioById', 'id', id);
      const localVarPath = `/scenarios/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all scenarios with optional filters
     * @param {GetScenariosGameTypeEnum} [gameType] Filter by game type
     * @param {GetScenariosDifficultyEnum} [difficulty] Filter by difficulty level
     * @param {GetScenariosCategoryEnum} [category] Filter by category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenarios: async (
      gameType?: GetScenariosGameTypeEnum,
      difficulty?: GetScenariosDifficultyEnum,
      category?: GetScenariosCategoryEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/scenarios`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (gameType !== undefined) {
        localVarQueryParameter['gameType'] = gameType;
      }

      if (difficulty !== undefined) {
        localVarQueryParameter['difficulty'] = difficulty;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get scenarios by category
     * @param {string} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenariosByCategory: async (
      category: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'category' is not null or undefined
      assertParamExists('getScenariosByCategory', 'category', category);
      const localVarPath = `/scenarios/category/{category}`.replace(
        `{${'category'}}`,
        encodeURIComponent(String(category)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ScenariosApi - functional programming interface
 * @export
 */
export const ScenariosApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ScenariosApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create a new scenario
     * @param {CreateScenarioDto} createScenarioDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createScenario(
      createScenarioDto: CreateScenarioDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(
        createScenarioDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ScenariosApi.createScenario']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a scenario by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScenarioById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ScenariosApi.getScenarioById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all scenarios with optional filters
     * @param {GetScenariosGameTypeEnum} [gameType] Filter by game type
     * @param {GetScenariosDifficultyEnum} [difficulty] Filter by difficulty level
     * @param {GetScenariosCategoryEnum} [category] Filter by category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScenarios(
      gameType?: GetScenariosGameTypeEnum,
      difficulty?: GetScenariosDifficultyEnum,
      category?: GetScenariosCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioResponseDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarios(
        gameType,
        difficulty,
        category,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ScenariosApi.getScenarios']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get scenarios by category
     * @param {string} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScenariosByCategory(
      category: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioResponseDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScenariosByCategory(
        category,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ScenariosApi.getScenariosByCategory']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ScenariosApi - factory interface
 * @export
 */
export const ScenariosApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ScenariosApiFp(configuration);
  return {
    /**
     *
     * @summary Create a new scenario
     * @param {CreateScenarioDto} createScenarioDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScenario(
      createScenarioDto: CreateScenarioDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ScenarioResponseDto> {
      return localVarFp
        .createScenario(createScenarioDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a scenario by ID
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenarioById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ScenarioResponseDto> {
      return localVarFp.getScenarioById(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all scenarios with optional filters
     * @param {GetScenariosGameTypeEnum} [gameType] Filter by game type
     * @param {GetScenariosDifficultyEnum} [difficulty] Filter by difficulty level
     * @param {GetScenariosCategoryEnum} [category] Filter by category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenarios(
      gameType?: GetScenariosGameTypeEnum,
      difficulty?: GetScenariosDifficultyEnum,
      category?: GetScenariosCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ScenarioResponseDto>> {
      return localVarFp
        .getScenarios(gameType, difficulty, category, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get scenarios by category
     * @param {string} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenariosByCategory(
      category: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ScenarioResponseDto>> {
      return localVarFp
        .getScenariosByCategory(category, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ScenariosApi - object-oriented interface
 * @export
 * @class ScenariosApi
 * @extends {BaseAPI}
 */
export class ScenariosApi extends BaseAPI {
  /**
   *
   * @summary Create a new scenario
   * @param {CreateScenarioDto} createScenarioDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenariosApi
   */
  public createScenario(createScenarioDto: CreateScenarioDto, options?: RawAxiosRequestConfig) {
    return ScenariosApiFp(this.configuration)
      .createScenario(createScenarioDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a scenario by ID
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenariosApi
   */
  public getScenarioById(id: string, options?: RawAxiosRequestConfig) {
    return ScenariosApiFp(this.configuration)
      .getScenarioById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all scenarios with optional filters
   * @param {GetScenariosGameTypeEnum} [gameType] Filter by game type
   * @param {GetScenariosDifficultyEnum} [difficulty] Filter by difficulty level
   * @param {GetScenariosCategoryEnum} [category] Filter by category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenariosApi
   */
  public getScenarios(
    gameType?: GetScenariosGameTypeEnum,
    difficulty?: GetScenariosDifficultyEnum,
    category?: GetScenariosCategoryEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return ScenariosApiFp(this.configuration)
      .getScenarios(gameType, difficulty, category, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get scenarios by category
   * @param {string} category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenariosApi
   */
  public getScenariosByCategory(category: string, options?: RawAxiosRequestConfig) {
    return ScenariosApiFp(this.configuration)
      .getScenariosByCategory(category, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetScenariosGameTypeEnum = {
  Cash: 'cash',
  Tournament: 'tournament',
} as const;
export type GetScenariosGameTypeEnum =
  typeof GetScenariosGameTypeEnum[keyof typeof GetScenariosGameTypeEnum];
/**
 * @export
 */
export const GetScenariosDifficultyEnum = {
  Beginner: 'beginner',
  Intermediate: 'intermediate',
  Advanced: 'advanced',
} as const;
export type GetScenariosDifficultyEnum =
  typeof GetScenariosDifficultyEnum[keyof typeof GetScenariosDifficultyEnum];
/**
 * @export
 */
export const GetScenariosCategoryEnum = {
  OpeningRanges: 'Opening Ranges',
  _3Betting: '3-Betting',
  DefendingBb: 'Defending BB',
  CallingRanges: 'Calling Ranges',
} as const;
export type GetScenariosCategoryEnum =
  typeof GetScenariosCategoryEnum[keyof typeof GetScenariosCategoryEnum];

/**
 * UserRangeAttemptsApi - axios parameter creator
 * @export
 */
export const UserRangeAttemptsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Compares a user range against the GTO reference range for a scenario and saves the attempt.
     * @summary Compare user range to GTO reference range
     * @param {CompareRangesDto} compareRangesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compareRanges: async (
      compareRangesDto: CompareRangesDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'compareRangesDto' is not null or undefined
      assertParamExists('compareRanges', 'compareRangesDto', compareRangesDto);
      const localVarPath = `/user-range-attempts/compare`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        compareRangesDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves all attempts for a specific user and scenario, sorted by attempt number.
     * @summary Get attempt history for a user and scenario
     * @param {string} userId The user ID
     * @param {string} scenarioId The scenario ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttemptHistory: async (
      userId: string,
      scenarioId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getAttemptHistory', 'userId', userId);
      // verify required parameter 'scenarioId' is not null or undefined
      assertParamExists('getAttemptHistory', 'scenarioId', scenarioId);
      const localVarPath = `/user-range-attempts/user/{userId}/scenario/{scenarioId}`
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)))
        .replace(`{${'scenarioId'}}`, encodeURIComponent(String(scenarioId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserRangeAttemptsApi - functional programming interface
 * @export
 */
export const UserRangeAttemptsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserRangeAttemptsApiAxiosParamCreator(configuration);
  return {
    /**
     * Compares a user range against the GTO reference range for a scenario and saves the attempt.
     * @summary Compare user range to GTO reference range
     * @param {CompareRangesDto} compareRangesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async compareRanges(
      compareRangesDto: CompareRangesDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ComparisonResultDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.compareRanges(
        compareRangesDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserRangeAttemptsApi.compareRanges']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieves all attempts for a specific user and scenario, sorted by attempt number.
     * @summary Get attempt history for a user and scenario
     * @param {string} userId The user ID
     * @param {string} scenarioId The scenario ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAttemptHistory(
      userId: string,
      scenarioId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRangeAttemptResponseDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAttemptHistory(
        userId,
        scenarioId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserRangeAttemptsApi.getAttemptHistory']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UserRangeAttemptsApi - factory interface
 * @export
 */
export const UserRangeAttemptsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserRangeAttemptsApiFp(configuration);
  return {
    /**
     * Compares a user range against the GTO reference range for a scenario and saves the attempt.
     * @summary Compare user range to GTO reference range
     * @param {CompareRangesDto} compareRangesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compareRanges(
      compareRangesDto: CompareRangesDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ComparisonResultDto> {
      return localVarFp
        .compareRanges(compareRangesDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves all attempts for a specific user and scenario, sorted by attempt number.
     * @summary Get attempt history for a user and scenario
     * @param {string} userId The user ID
     * @param {string} scenarioId The scenario ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttemptHistory(
      userId: string,
      scenarioId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<UserRangeAttemptResponseDto>> {
      return localVarFp
        .getAttemptHistory(userId, scenarioId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserRangeAttemptsApi - object-oriented interface
 * @export
 * @class UserRangeAttemptsApi
 * @extends {BaseAPI}
 */
export class UserRangeAttemptsApi extends BaseAPI {
  /**
   * Compares a user range against the GTO reference range for a scenario and saves the attempt.
   * @summary Compare user range to GTO reference range
   * @param {CompareRangesDto} compareRangesDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserRangeAttemptsApi
   */
  public compareRanges(compareRangesDto: CompareRangesDto, options?: RawAxiosRequestConfig) {
    return UserRangeAttemptsApiFp(this.configuration)
      .compareRanges(compareRangesDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves all attempts for a specific user and scenario, sorted by attempt number.
   * @summary Get attempt history for a user and scenario
   * @param {string} userId The user ID
   * @param {string} scenarioId The scenario ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserRangeAttemptsApi
   */
  public getAttemptHistory(userId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
    return UserRangeAttemptsApiFp(this.configuration)
      .getAttemptHistory(userId, scenarioId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {object} body Confirm email by decoding token and updating user in DB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('confirm', 'body', body);
      const localVarPath = `/users/confirm`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {object} body Create user from payload, send verification email and return created user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createUser', 'body', body);
      const localVarPath = `/users/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} uuid User UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserByUuid: async (
      uuid: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteUserByUuid', 'uuid', uuid);
      const localVarPath = `/users/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users/files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ResetPwdDto} resetPwdDto Reset user password from payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPwd: async (
      resetPwdDto: ResetPwdDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'resetPwdDto' is not null or undefined
      assertParamExists('resetPwd', 'resetPwdDto', resetPwdDto);
      const localVarPath = `/users/reset-pwd`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resetPwdDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {object} body Confirm email by decoding token and updating user in DB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirm(
      body: object,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirm(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.confirm']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {object} body Create user from payload, send verification email and return created user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      body: object,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEntity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {any} uuid User UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserByUuid(
      uuid: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserByUuid(uuid, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.deleteUserByUuid']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUsers(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsers(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.deleteUsers']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserFiles(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileEntity>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFiles(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.getUserFiles']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserEntity>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {ResetPwdDto} resetPwdDto Reset user password from payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetPwd(
      resetPwdDto: ResetPwdDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetPwd(resetPwdDto, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.resetPwd']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @param {object} body Confirm email by decoding token and updating user in DB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm(body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.confirm(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {object} body Create user from payload, send verification email and return created user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: object, options?: RawAxiosRequestConfig): AxiosPromise<UserEntity> {
      return localVarFp.createUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {any} uuid User UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserByUuid(uuid: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.deleteUserByUuid(uuid, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUsers(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.deleteUsers(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFiles(options?: RawAxiosRequestConfig): AxiosPromise<Array<FileEntity>> {
      return localVarFp.getUserFiles(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserEntity>> {
      return localVarFp.getUsers(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ResetPwdDto} resetPwdDto Reset user password from payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPwd(resetPwdDto: ResetPwdDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.resetPwd(resetPwdDto, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @param {object} body Confirm email by decoding token and updating user in DB
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public confirm(body: object, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .confirm(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body Create user from payload, send verification email and return created user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUser(body: object, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .createUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} uuid User UUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUserByUuid(uuid: any, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .deleteUserByUuid(uuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUsers(options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .deleteUsers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserFiles(options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUserFiles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUsers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ResetPwdDto} resetPwdDto Reset user password from payload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public resetPwd(resetPwdDto: ResetPwdDto, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .resetPwd(resetPwdDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
